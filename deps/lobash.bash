# This file is generated by https://github.com/adoyle-h/lobash
# Author: ADoyle <adoyle.h@gmail.com>
# License: Apache License Version 2.0
# Version: 0.1.0
# Prefix: l.

######################## Lobash Internals ########################

_lobash.0_1_0_595550_21144_detect_os() {
  local kernel_name
  kernel_name="$(uname -s)"

  case "$kernel_name" in
    "Darwin")                         echo MacOS ;;
    "SunOS")                          echo Solaris ;;
    "Haiku")                          echo Haiku ;;
    "MINIX")                          echo MINIX ;;
    "AIX")                            echo AIX ;;
    "IRIX"*)                          echo IRIX ;;
    "FreeMiNT")                       echo FreeMiNT ;;
    "Linux" | "GNU"*)                 echo Linux ;;
    *"BSD" | "DragonFly" | "Bitrig")  echo BSD ;;
    "CYGWIN"* | "MSYS"* | "MINGW"*)   echo Windows ;;
    *)                                echo Unknown_OS "$kernel_name" ;;
  esac
}

_lobash.0_1_0_595550_21144_is_bash() {
  [[ -n "${BASH_VERSION:-}" ]] && echo true || echo false
}

# ---
# Dependent_Internal: detect_os
# ---

# shellcheck disable=SC2034

# Prevent multiple executions
[[ -n ${_LOBASH_0_1_0_595550_21144_INTERNAL_FUNC_PREFIX:-} ]] && return

readonly _LOBASH_0_1_0_595550_21144_INTERNAL_FUNC_PREFIX=_lobash.
readonly _LOBASH_0_1_0_595550_21144_INTERNAL_CONST_PREFIX=_LOBASH_
readonly _LOBASH_0_1_0_595550_21144_PRIVATE_FUNC_PREFIX=_l.
readonly _LOBASH_0_1_0_595550_21144_PRIVATE_CONST_PREFIX=_L_
readonly _LOBASH_0_1_0_595550_21144_PUBLIC_FUNC_PREFIX=l.
readonly _LOBASH_0_1_0_595550_21144_PUBLIC_CONST_PREFIX=L_
# _LOBASH_0_1_0_595550_21144_PREFIX will be reassigned when ./build
_LOBASH_0_1_0_595550_21144_PREFIX=l.

readonly _LOBASH_0_1_0_595550_21144_OS=$(_lobash.0_1_0_595550_21144_detect_os)

_lobash.0_1_0_595550_21144_check_os() {
  if [[ ! $_LOBASH_0_1_0_595550_21144_OS =~ ^(Linux|MacOS|BSD)$ ]]; then
    echo "Not support current system: $_LOBASH_0_1_0_595550_21144_OS" >&2
    return 5
  fi
}

_lobash.0_1_0_595550_21144_check_shell() {
  if [[ $(_lobash.0_1_0_595550_21144_is_bash) == false ]]; then
    echo 'Lobash only work in Bash.' >&2
    return 6
  fi
}

_lobash.0_1_0_595550_21144_check_supported_bash_version() {
  if [[ ${BASH_VERSINFO[0]} -lt 4 ]] \
    || ([[ ${BASH_VERSINFO[0]} == 4 ]] && [[ ${BASH_VERSINFO[1]} -lt 4 ]]); then
    echo "Bash $BASH_VERSION is not supported. Upgrade your Bash to 4.4 or higher version." >&2
    return 7
  fi
}

_lobash.0_1_0_595550_21144_check_support() {
  _lobash.0_1_0_595550_21144_check_os
  _lobash.0_1_0_595550_21144_check_shell
  _lobash.0_1_0_595550_21144_check_supported_bash_version
}

_lobash.0_1_0_595550_21144_check_support

_lobash.0_1_0_595550_21144_dirname() {
  local str=${1:-}
  [[ $str == '/' ]] && echo '/' && return 0
  [[ $str =~ ^'../' ]] && echo '.' && return 0
  [[ ! $str =~ / ]] && echo '.' && return 0

  printf '%s\n' "${str%/*}"
}

# Usage: _lobash.0_1_0_595550_21144_debug <message>...
# Print logs to stdout.
# If LOBASH_DEBUG set, print Lobash debug logs to stdout
# If LOBASH_DEBUG_OUTPUT set, logs pipe to $LOBASH_DEBUG_OUTPUT instead of stdout
#
# It will not print logs to stdout in below scenario:
#
#   LOBASH_DEBUG=1
#   foo() { debug hello; }
#   bar=$(foo) # => Not see any log in shell
#
# LOBASH_DEBUG_OUTPUT can resolve the problem.
#
#   LOBASH_DEBUG=1
#   LOBASH_DEBUG_OUTPUT=/tmp/log
#   foo() { debug2 hello; }
#   bar=$(foo) # => Still not see any log in shell, but logs records in file /tmp/log
_lobash.0_1_0_595550_21144_debug() {
  [[ -z ${LOBASH_DEBUG:-} ]] && return

  local func=${FUNCNAME[1]}

  if [[ -z ${LOBASH_DEBUG_OUTPUT:-} ]]; then
    echo "[DEBUG:LOBASH:$func] $*"
  else
    echo "[DEBUG:LOBASH:$func] $*" >> "$LOBASH_DEBUG_OUTPUT"
  fi
}

# Usage: _lobash.0_1_0_595550_21144_warn <message>...
# Print logs to stdrr.
# If LOBASH_WARN_OUTPUT set, logs pipe to $LOBASH_WARN_OUTPUT instead of stdrr
#
# It will not print logs to stdout in below scenario:
#
#   foo() { warn hello; }
#   bar=$(foo) # => Not see any log in shell
#
# LOBASH_WARN_OUTPUT can resolve the problem.
#
#   LOBASH_WARN_OUTPUT=/tmp/log
#   foo() { warn2 hello; }
#   bar=$(foo) # => Still not see any log in shell, but logs records in file /tmp/log
_lobash.0_1_0_595550_21144_warn() {
  local func=${FUNCNAME[1]}

  if [[ -z ${LOBASH_WARN_OUTPUT:-} ]]; then
    echo "[WARN:LOBASH:$func] $*" >&2
  else
    echo "[WARN:LOBASH:$func] $*" >> "$LOBASH_WARN_OUTPUT"
  fi
}

# Usage: _lobash.0_1_0_595550_21144_error <message>...
# Print logs to stdrr.
# If LOBASH_WARN_OUTPUT set, logs pipe to $LOBASH_WARN_OUTPUT instead of stdrr
#
# It will not print logs to stdout in below scenario:
#
#   foo() { error hello; }
#   bar=$(foo) # => Not see any log in shell
#
# LOBASH_WARN_OUTPUT can resolve the problem.
#
#   LOBASH_WARN_OUTPUT=/tmp/log
#   foo() { warn2 hello; }
#   bar=$(foo) # => Still not see any log in shell, but logs records in file /tmp/log
_lobash.0_1_0_595550_21144_error() {
  if [[ -z ${LOBASH_WARN_OUTPUT:-} ]]; then
    echo "[ERROR:LOBASH] $*" >&2
  else
    echo "[ERROR:LOBASH] $*" >> "$LOBASH_WARN_OUTPUT"
  fi
}

# ---
# Category: Lobash
# Since: 0.1.0
# Usage: import [-f|--force] <module_name>... [<prefix>=l.]
# Description: Import Lobash modules.
# Description: <prefix> must end with `.`, `-`, `_`
# Description: -f, --force  To force refresh module codes. Because imported modules will be cached by default.
# ---

## Usage: _lobash.0_1_0_595550_21144_get_module_path <module_name>
_lobash.0_1_0_595550_21144_get_module_path() {
  if [[ -z ${IS_LOBASH_TEST:-} ]]; then
    printf '%s\n' "$(_lobash.0_1_0_595550_21144_dirname "${BASH_SOURCE[0]}")/../modules/$1.bash"
  else
    printf '%s\n' "$LOBASH_ROOT_DIR/src/modules/$1.bash"
  fi
}

_lobash.0_1_0_595550_21144_import_deps() {
  local module_path=$1
  local deps

  # Get list of dependent modules names
  read -ra deps <<< "$( grep '^# Dependent:' < "$module_path" \
    | sed -E 's/^# Dependent: ?(.*)/\1/;s/,/ /g' \
    || true )"

  _lobash.0_1_0_595550_21144_debug "To load deps modules. deps.size=${#deps[*]}"
  if [[ ${#deps[@]} -gt 0 ]]; then
    _lobash.0_1_0_595550_21144_imports "${deps[@]}"
  fi
}

_lobash.0_1_0_595550_21144_import() {
  local module_name=$1
  local is_force=${2:-false}

  _lobash.0_1_0_595550_21144_debug "S1. To load module. name=${module_name}"

  [[ -z $module_name ]] && _lobash.0_1_0_595550_21144_error "Module name cannot be empty string." && return 3

  # Associative array only allow [a-zA-Z0-9_] for key naming
  local import_key=_lobash_import_cache_${module_name//[^a-zA-Z0-9]/_}
  if [[ $is_force == false ]] && [[ "${!import_key:-}" == loaded ]]; then
    _lobash.0_1_0_595550_21144_debug "import_key=${import_key} is loaded. skip load"
    return;
  else
    # To load module source code
    local module_path
    module_path=$(_lobash.0_1_0_595550_21144_get_module_path "$module_name")
    _lobash.0_1_0_595550_21144_debug "S2. module_name=${module_name} module_path=${module_path}"
    [[ ! -f $module_path ]] && _lobash.0_1_0_595550_21144_error "Not found module '${module_name}'." && return 4

    _lobash.0_1_0_595550_21144_import_deps "$module_path"

    _lobash.0_1_0_595550_21144_debug "S5. To load the source code of main module. module_path=$module_path"
    source "$module_path"

    read -r "$import_key" <<< 'loaded'
  fi

  _lobash.0_1_0_595550_21144_debug "Loaded module. import_key=${import_key}"
}

_lobash.0_1_0_595550_21144_imports() {
  local is_force=false
  if [[ ${1:-} == '-f' ]] || [[ ${1:-} == '--force' ]]; then
    shift
    is_force=true
  fi

  local name
  for name in "$@"; do
    _lobash.0_1_0_595550_21144_import "$name" "$is_force"
  done
}
_LOBASH_0_1_0_595550_21144_PREFIX=l.

######################## Private Methods ########################

# ---
# Category: Array
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_array_include <array_name> <match>
# ---

l.0_1_0_595550_21144_array_include() {
  local -n l_array_include_arg_array=$1
  local match="$2"
  local e
  shift
  for e in "${l_array_include_arg_array[@]}"; do
    [[ "$e" == "$match" ]] && echo true && return 0;
  done

  echo false
}

# ---
# Category: Prompt
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_ask <message> [<default>=Y]
# Description: Print a message and read Yes/No answer from stdin.
# Description: when default=Y, if will return YES by default.
# Description: when default=N, if will return NO by default.
# Dependent: lower_case
# ---

l.0_1_0_595550_21144_ask() {
  local msg=$1
  local default=${2:-Y}
  local prompt
  if [[ $default == Y ]]; then
    default=YES
    prompt='([Y]es/No)'
  elif [[ $default == N ]]; then
    default=NO
    prompt='(Yes/[N]o)'
  else
    echo "Invalid argument 'default'. Valid value is 'Y' and 'N'. Current=${default}" >&2
    return 3
  fi

  local answer
  read -rp "$msg $prompt " answer

  answer=$(l.0_1_0_595550_21144_lower_case "$answer")
  if [[ $answer =~ ^ye?s?$ ]]; then
    echo YES
  elif [[ $answer =~ ^no?$ ]]; then
    echo NO
  elif [[ $answer == '' ]]; then
    echo "$default"
  else
    echo 'Invalid Answer'
  fi

  return 0
}

# ---
# Category: Path
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_basename <path>
# Description: Alternative to basename command. It much faster because using shell parameter expansion.
# ---

l.0_1_0_595550_21144_basename() {
  local str=${1:-}
  str="${str%/}"
  printf '%s\n' "${str##*/}"
}

# ---
# Category: Path
# Since: 0.1.0
# Usage: echo <path> | l.0_1_0_595550_21144_basename.p
# Description: The pipeline version of l.0_1_0_595550_21144_basename
# Dependent: basename
# ---

l.0_1_0_595550_21144_basename.p() {
  local str
  IFS='' read -r str

  l.0_1_0_595550_21144_basename "$str"
}

# ---
# Category: Util
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_benchmark <command> [<repeats>=10]
# Description: Run command in repeats to get benchmarks.
# ---

_l.0_1_0_595550_21144_run_benchmark() {
  local c=$1
  local repeats=$2

  # Run the given command [repeats] times
  for (( i = 1; i <= "$repeats" ; i++ )); do
    $c > /dev/null 2>&1
  done;
}

l.0_1_0_595550_21144_benchmark() {
  local c=$1
  local repeats=${2:-10}

  echo "Benchmarking: Run command '$c' [$repeats] times.";
  echo "============="
  type "$c"
  echo "============="

  time _l.0_1_0_595550_21144_run_benchmark "$c" "$repeats"

  printf '\n--------------------------\n\n'
}

# ---
# Category: Prompt
# Since: 0.1.0
# Dependent: is_integer
# Usage: l.0_1_0_595550_21144_choose <item>...
# Description: Prompt user to choose one item from options. The function will return the value of chosen item.
# ---

l.0_1_0_595550_21144_choose() {
  local items=("$@")

  # command may invoked in no-login shell
  if [[ $- =~ i ]]; then
    printf -- '  %s\n' 'No. Item' >/dev/tty
    local i
    for i in "${!items[@]}"; do
      printf -- '- %-2d  %s\n' $(("$i" + 1)) "${items[$i]}" >/dev/tty
    done
  fi

  local num
  read -r -p "Please enter the number to choose: " num

  local r
  r=$(l.0_1_0_595550_21144_is_integer "$num")
  [[ $r == false ]] && echo "Must enter an integer. Current: $num">&2 && return 3

  if [[ $num -gt ${#items[@]} ]] || [[ $num -lt 1 ]]; then
   printf '%s\n' "Invalid choose number: $num" >&2
   return 4
  fi

  printf '%s\n' "${items[$((num - 1))]}"
}

# ---
# Category: Util
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_compose [<function_name_or_string>]...
# Description: Function composition
# ---

l.0_1_0_595550_21144_compose() {
  local -a last=()
  for f in "$@"; do
    if [[ $(type -t "$f") == function ]]; then
      last=( "$($f "${last[@]}")" )
    else
      last=( "$f" )
    fi
  done
  printf '%s\n' "${last[@]}"
}

# ---
# Category: File
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_count_file_lines <filepath>
# Description: Count lines of file. Similar to `wc -l`.
# ---

# readarray slow than wc
# l.0_1_0_595550_21144_count_file_lines() {
#   # readarray supported since bash 4.0
#   readarray -tn 0 lines < "$1"
#   printf '%s\n' "${#lines[@]}"
# }

l.0_1_0_595550_21144_count_file_lines() {
  wc -l < "$1" | tr -d ' '
}

# ---
# Category: File
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_count_files <directory_path>
# Description: Count the sum of files under `<directory_path>`.
# ---

l.0_1_0_595550_21144_count_files() {
  local files
  # compgen will return 1 when no matched files
  files=( $(compgen -f "$1"/ || [[ $? == 1 ]]) )
  printf '%s\n' "${#files[@]}"
}

# ---
# Category: String
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_count_lines <string>
# Description: Count lints of string like `wc -l`.
# Description: The Bash command substitution always trim blank line. So l.0_1_0_595550_21144_count_lines do not accept normal parameter passing.
# Description: Refer to https://stackoverflow.com/a/37706905
# ---

l.0_1_0_595550_21144_count_lines() {
  printf '%b' "$1" | wc -l | tr -d ' '
}

# ---
# Category: String
# Since: 0.1.0
# Usage: echo <string> | l.0_1_0_595550_21144_count_lines.p
# Description: The pipeline version of l.0_1_0_595550_21144_count_lines
# ---

l.0_1_0_595550_21144_count_lines.p() {
  local count=0
  while read -r -d $'\n' _; do
    ((count+=1))
  done
  printf '%s\n' "$count"
}

# ---
# Category: Variable
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_cur_function_name
# Description: Return the name of current function where the l.0_1_0_595550_21144_cur_function_name called in.
# ---

l.0_1_0_595550_21144_cur_function_name() {
  printf '%s\n' "${FUNCNAME[1]}"
}

# ---
# Category: Terminal
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_cursor_col
# Description: Get column number of current cursor position.
# ---

# Refer to https://unix.stackexchange.com/a/183121
l.0_1_0_595550_21144_cursor_col() {
  local COL
  IFS=';' read -rsdR -p $'\E[6n' _ COL
  echo "${COL}"
}

# ---
# Category: Terminal
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_cursor_pos
# Usage: IFS=';' c_pos=( $(l.0_1_0_595550_21144_cursor_pos) )
# Description: Get current cursor position. It will print "row;column" with default IFS.
# ---

# l.0_1_0_595550_21144_cursor_pos() {
#   stty size
# }

# Refer to https://unix.stackexchange.com/a/183121
l.0_1_0_595550_21144_cursor_pos() {
  local CURPOS
  read -rsdR -p $'\E[6n' CURPOS
  CURPOS=${CURPOS#*[} # Strip decoration characters <ESC>[
  echo "${CURPOS}"    # Return position in "row;col" format
}

# ---
# Category: Terminal
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_cursor_row
# Description: Get row number of current cursor position.
# ---

# Refer to https://unix.stackexchange.com/a/183121
l.0_1_0_595550_21144_cursor_row() {
  local ROW
  IFS=';' read -rsdR -p $'\E[6n' ROW _
  # Strip decoration characters <ESC>[
  echo "${ROW#*[}"
}

# ---
# Category: Time
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_date [<format>=]
# Description: Refer to 'man strftime' for `<format>`.
# ---

# Reference: https://github.com/dylanaraps/pure-bash-bible#get-the-current-date-using-strftime
l.0_1_0_595550_21144_date() {
  # %(datefmt)T : Causes printf to output the date-time string resulting from using datefmt as a
  # format string for strftime(3). The corresponding argument is an integer representing the number
  # of seconds since the epoch. Two special argument values may be used: -1 represents the
  # current time, and -2 represents the time the shell was invoked. If no argument is specified,
  # conversion behaves as if -1 had been given. This is an exception to the usual printf behavior.
  printf "%($1)T\\n" "-1"
}

# ---
# Category: System
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_detect_os
# Description: Return the name of current operator system.
# ---

l.0_1_0_595550_21144_detect_os() {
  _lobash.0_1_0_595550_21144_detect_os
}

# ---
# Category: Path
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_dirname <path>
# Description: Alternative to dirname command. It much faster because using shell parameter expansion.
# ---

l.0_1_0_595550_21144_dirname() {
  _lobash.0_1_0_595550_21144_dirname "${1:-}"
}

# ---
# Category: Path
# Since: 0.1.0
# Usage: echo <path> | l.0_1_0_595550_21144_dirname.p
# Description: The pipeline version of l.0_1_0_595550_21144_dirname
# ---

l.0_1_0_595550_21144_dirname.p() {
  local str
  IFS='' read -r str
  _lobash.0_1_0_595550_21144_dirname "$str"
}

# ---
# Category: Console
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_echo <string>...
# Description: A easy and safe way to print string. Not support any options.
# Description: The builtin echo will get unexpected result while execute `b=( -n 123 ); echo "${b[@]}"`.
# Description: See https://github.com/anordal/shellharden/blob/master/how_to_do_things_safely_in_bash.md#echo--printf
# ---

l.0_1_0_595550_21144_echo() {
  printf -- '%b\n' "$*"
}

# ---
# Category: Console
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_echo_array <array_name>
# Description: Print each values of array with newline.
# ---

l.0_1_0_595550_21144_echo_array() {
  local -n l_echo_array_arg1=$1
  printf '%s\n' "${l_echo_array_arg1[@]}"
}

# ---
# Category: String
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_end_with <string> <match>
# Description: Return `true` or `false`.
# ---

l.0_1_0_595550_21144_end_with() {
  [[ ${1%%"$2"}$2 == "$1" ]] && echo true || echo false
}

# ---
# Category: File
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_extname <path>
# Description: Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last portion of the path. If there is no . in the last portion of the path, or if the first character of the basename of path (see path.basename()) is ., then an empty string is returned.
# ---

l.0_1_0_595550_21144_extname() {
  local path=${1:-}
  [[ $path =~ ^\. ]] && echo '' && return
  [[ ! $path =~ \. ]] && echo '' && return
  echo ".${path##*.}"
}

# ---
# Category: File
# Since: 0.1.0
# Usage: echo <path> | l.0_1_0_595550_21144_extname.p
# Description: The pipeline of l.0_1_0_595550_21144_extname
# Dependent: extname
# ---

l.0_1_0_595550_21144_extname.p() {
  local path
  IFS='' read -r path
  l.0_1_0_595550_21144_extname "$path"
}

# ---
# Category: Array
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_first <array_name>
# Description: Return the first value of array.
# ---

l.0_1_0_595550_21144_first() {
  local -n l_first_arg1=$1
  printf '%s\n' "${l_first_arg1[@]:0:1}"
}

# ---
# Category: Condition
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_has <condition> <what>
# Usage: l.0_1_0_595550_21144_has not <condition> <what>
# Description: Exit with 0 or 1. Check if command/function/alias/keyword/builtin or anything existed.
# Description: `<condition>` Valid value: `command`, `function`, `alias`, `keyword`, `builtin`, `the`
# Description: This method is not recommended. Use strict_has instead.
# ---

# Reference: https://github.com/qzb/is.sh/blob/master/is.sh
l.0_1_0_595550_21144_has() {
  local condition="$1"
  local value="$2"

  if [[ "$condition" == "not" ]]; then
    shift 1

    local e=false
    [[ $- =~ e ]] && e=true
    set +e
    l.0_1_0_595550_21144_has "${@}"
    local result=$?
    [[ $e == true ]] && set -e

    if [[ $result == 0 ]]; then
      return 1
    elif [[ $result == 1 ]]; then
      return 0
    else
      return $result
    fi
  fi

  case "$condition" in
    command)
      [[ -x "$(command -v "$value")" ]] && return 0;;
    function)
      [[ $(type -t "$value") == function ]] && return 0;;
    alias)
      [[ $(type -t "$value") == alias ]] && return 0;;
    keyword)
      [[ $(type -t "$value") == keyword ]] && return 0;;
    builtin)
      [[ $(type -t "$value") == builtin ]] && return 0;;
    the)
      type -t "$value"
      return $?;;
    *)
      echo "Invalid Condition: $condition" >&2
      return 3;;
  esac > /dev/null

  return 1
}

# ---
# Category: Color
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_hex_to_rgb <HEX>
# Description: Return a list contains `<R> <G> <B>`.
# ---

# Reference: https://github.com/dylanaraps/pure-bash-bible#convert-a-hex-color-to-rgb
l.0_1_0_595550_21144_hex_to_rgb() {
  local hex r g b
  hex="${1/\#}"

  if (( ${#hex} == 6 )); then
    ((r=16#${hex:0:2},g=16#${hex:2:2},b=16#${hex:4:2})) || true
  elif (( ${#hex} == 3 )); then
    ((r=16#${hex:0:1}${hex:0:1},g=16#${hex:1:1}${hex:1:1},b=16#${hex:2:1}${hex:2:1})) || true
  else
    echo 'Argument is not a hex.' >&2
    return 3
  fi

  printf '%s\n%s\n%s\n' "$r" "$g" "$b"
}

# ---
# Category: System
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_hostname
# Description: Return current hostname.
# ---

l.0_1_0_595550_21144_hostname() {
  printf '%s\n' "${HOSTNAME:-$(hostname)}"
}

# ---
# Category: Condition
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_if <condition> <then> [<else>]
# Description: The difference from shell builtin `if` is when condition function throw exception it will ended immediately.
# Description: `<condition>` can be function name, string and number. The function should return `true`/`0` or `false`/`1`.
# Description: `<then>` and `<else>` must be function name. And `<else>` is optional.
# Description: When `<condition>` is true, `<then>` function will be invoked. Otherwise `<else>` will be invoked if it passed.
# ---

l.0_1_0_595550_21144_if() {
  local condition
  if [[ $(type -t "$1") == function ]]; then
    condition=$($1)
  else
    condition=$1
  fi

  if [[ $condition == true ]] || [[ $condition == 0 ]]; then
    $2
  elif [[ $condition == false ]] || [[ $condition == 1 ]]; then
    ${3:-}
  else
    echo "Invalid condition: $condition"
    return 3
  fi
}

# ---
# Category: Arithmetic
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_inc <var_name> [<addend>=1]
# Description: Increase number with addend.
# ---

l.0_1_0_595550_21144_inc() {
  local -n l_inc_arg1=$1
  ((l_inc_arg1+=${2:-1})) || true
}

# ---
# Category: Condition
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_is_array <var_name>
# Description: Return `true` or `false`.
# ---

l.0_1_0_595550_21144_is_array() {
  [[ -z ${1:-} ]] && echo false && return 0

  local str
  str=$(declare -p -- "$1" 2>/dev/null || true)
  [[ -z $str ]] && echo false && return 0

  local start="declare -a "
  [[ $start${str##"$start"} == "$str" ]] && echo true || echo false
}

# ---
# Category: Condition
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_is_bash
# Description: Return `true` or `false`.
# ---

l.0_1_0_595550_21144_is_bash() {
  _lobash.0_1_0_595550_21144_is_bash
}

# ---
# Category: Condition
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_is_dir <path>
# Description: Return `true` or `false`.
# ---

l.0_1_0_595550_21144_is_dir() {
  [[ -d ${1:-} ]] && echo true || echo false
}

# ---
# Category: Condition
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_is_executable <path>
# Description: Similar to `[[ -x ]]`. Return `true` or `false`.
# ---

l.0_1_0_595550_21144_is_executable() {
  [[ -x ${1:-} ]] && echo true || echo false
}

# ---
# Category: Condition
# Since: 0.1.0
# Dependent: is_dir
# Usage: l.0_1_0_595550_21144_is_executable_file <path>
# Description: Similar to `l.0_1_0_595550_21144_is_executable`. But if `<path>` is directory it will return false.
# ---

l.0_1_0_595550_21144_is_executable_file() {
  local r
  r=$(l.0_1_0_595550_21144_is_dir "${1:-}")
  if [[ $r == true ]]; then
    # directory is executable
    # https://superuser.com/a/168583
    echo false
  else
    [[ -x $1 ]] && echo true || echo false
  fi
}

# ---
# Category: Condition
# Since: 0.1.0
# Dependent: is_integer
# Usage: l.0_1_0_595550_21144_is_false <var>
# Description: Return `true` or `false`.
# ---

l.0_1_0_595550_21144_is_false() {
  local r
  r=$(l.0_1_0_595550_21144_is_integer "${1:-}")

  if [[ $r == true ]]; then
    if [[ ${1:-} != 0 ]]; then
      echo true
    else
      echo false
    fi
  else
    if [[ ${1:-} == false ]]; then
      echo true
    else
      echo false
    fi
  fi
}

# ---
# Category: Condition
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_is_file <path>
# Description: Return `true` or `false`.
# ---

l.0_1_0_595550_21144_is_file() {
  [[ -f ${1:-} ]] && echo true || echo false
}

# ---
# Category: Condition
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_is_float <str>
# Description: Return `true` or `false`.
# ---

l.0_1_0_595550_21144_is_float() {
  [[ ${1:-} =~ ^[-+]?[0-9]+([.][0-9]+)?$ ]] && echo true || echo false
}

# ---
# Category: Condition
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_is_integer <str>
# Description: Return `true` or `false`.
# ---

l.0_1_0_595550_21144_is_integer() {
  [[ ${1:-} =~ ^[-+]?[0-9]+$ ]] && echo true || echo false
}

# ---
# Category: Condition
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_is_link <path>
# Description: Return `true` or `false`.
# ---

l.0_1_0_595550_21144_is_link() {
  [[ -L ${1:-} ]] && echo true || echo false
}

# ---
# Category: Condition
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_is_number <str>
# Description: Return `true` or `false`.
# ---

l.0_1_0_595550_21144_is_number() {
  [[ ${1:-} =~ ^[-+]?[0-9]+(.[0-9]+)?$ ]] && echo true || echo false
}

# ---
# Category: Condition
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_is_readable <path>
# Description: Return `true` or `false`.
# ---

l.0_1_0_595550_21144_is_readable() {
  [[ -r ${1:-} ]] && echo true || echo false
}

# ---
# Category: Condition
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_is_true <str>
# Description: Return `true` or `false`.
# ---

l.0_1_0_595550_21144_is_true() {
  if [[ ${1:-} == true ]] || [[ ${1:-} == 0 ]]; then
    echo true
  else
    echo false
  fi
}

# ---
# Category: Condition
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_is_writeable <path>
# Description: Return `true` or `false`.
# ---

l.0_1_0_595550_21144_is_writeable() {
  [[ -w ${1:-} ]] && echo true || echo false
}

# ---
# Category: Condition
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_is_zsh
# Description: Return `true` or `false`.
# ---

l.0_1_0_595550_21144_is_zsh() {
  [[ -n "${ZSH_VERSION:-}" ]] && echo true || echo false
}

# ---
# Category: String
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_join <array_name> [<delimiter>=,]
# Description: Convert all elements in array into a string separated by delimiter.
# ---

l.0_1_0_595550_21144_join() {
  local -n l_join_arg1=$1
  local _IFS=$IFS
  if [[ $# == 1 ]]; then
    IFS=,
  else
    IFS=${2}
  fi
  printf '%s\n' "${l_join_arg1[*]}"
  IFS=$_IFS
}

# ---
# Category: Array
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_last <array_name>
# Description: Return the last value of array.
# ---

l.0_1_0_595550_21144_last() {
  local -n l_last_arg1=$1
  printf '%s\n' "${l_last_arg1[@]: -1:1}"
}

# ---
# Category: String
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_lower_case <string>
# Description: Convert all characters of string to lower case.
# ---

# An alternative for Bash 3.x
# l.0_1_0_595550_21144_lower_case() {
#   tr '[:upper:]' '[:lower:]' <<< ${1:-}
# }

l.0_1_0_595550_21144_lower_case() {
  local str=${1:-}
  printf '%s\n' "${str,,}"
}

# ---
# Category: String
# Since: 0.1.0
# Usage: echo <string> | l.0_1_0_595550_21144_lower_case.p
# Description: The pipeline version of l.0_1_0_595550_21144_lower_case
# Dependent: lower_case
# ---

l.0_1_0_595550_21144_lower_case.p() {
  local str
  IFS='' read -r str
  l.0_1_0_595550_21144_lower_case "$str"
}

# ---
# Category: String
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_lower_first <string>
# Usage: echo <string> | l.0_1_0_595550_21144_lower_first
# Description: Convert the first character of string to lower case.
# ---

l.0_1_0_595550_21144_lower_first() {
  local str=${1:-}
  printf '%s\n' "${str,}"
}

# ---
# Category: String
# Since: 0.1.0
# Usage: echo <string> | l.0_1_0_595550_21144_lower_first.p
# Description: The pipeline version of l.0_1_0_595550_21144_lower_first
# Dependent: lower_first
# ---

l.0_1_0_595550_21144_lower_first.p() {
  local str
  IFS='' read -r str
  l.0_1_0_595550_21144_lower_first "$str"
}

# ---
# Category: String
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_match "string" "regex" [index=1]
# Description: Return matched part of string. Return empty string if no matched. Support capturing groups.
# ---

l.0_1_0_595550_21144_match() {
  [[ ${3:-} == 0 ]] && echo "index cannot be 0" >&2 && return 3

  if [[ $1 =~ $2 ]]; then
    if (( ${#BASH_REMATCH[@]} > 1 )); then
      printf '%s\n' "${BASH_REMATCH[${3:-1}]}"
    else
      echo ''
    fi
  else
    echo ''
  fi
}

# ---
# Category: Path
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_normalize <path>
# Description: Normalize the given path which can be an unexisted path.
# Description: Trailing `/` always be removed.
# Dependent: split, join
# ---

l.0_1_0_595550_21144_normalize() {
  local path=${1:-}

  if [[ -z ${path} ]]; then
    echo '.'
    return 0
  fi

  if [[ ${path} == '.' ]]; then
    echo '.'
    return 0
  fi

  local -a words
  l.0_1_0_595550_21144_split "$path" words '/'
  local -a list=()
  local -a pre_list=()
  local n=0
  local i

  if [[ ${path:0:1} == '/' ]]; then
    pre_list+=(/)
  else
    for i in "${words[@]}"; do
      if [[ $i =~ ^'.' ]]; then
        ((n+=1))
        pre_list+=("$i")
      else
        break
      fi
    done
  fi

  for (( ; n < ${#words[@]}; n++ )); do
    i=${words[$n]}
    if [[ $i == '' ]] || [[ $i == '.' ]]; then
      true
    elif [[ $i == '..' ]]; then
      local k=$(( ${#list[@]} - 1)) || true
      [[ $k > -1 ]] && unset list["$k"]
    else
      list+=("$i")
    fi
  done

  printf '%s%s\n' "$(l.0_1_0_595550_21144_join pre_list '/')" "$(l.0_1_0_595550_21144_join list '/')"
}

# ---
# Category: Path
# Since: 0.1.0
# Usage: echo <path> | l.0_1_0_595550_21144_normalize.p
# Description: The pipeline version of l.0_1_0_595550_21144_normalize
# Dependent: normalize
# ---

l.0_1_0_595550_21144_normalize.p() {
  local path
  IFS='' read -r path
  l.0_1_0_595550_21144_normalize "$path"
}

# ---
# Category: Condition
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_not <condition>
# Description: `<condition>` must be `true` or `false`. This function returns the opposite value.
# ---

l.0_1_0_595550_21144_not() {
  local condition="${1:-}"

  if [[ $condition == true ]]; then
    echo false;
  elif [[ $condition == false ]]; then
    echo true
  else
    echo "Invalid condition! It must be one of 'true' and 'false'. Current value=$condition" >&2
    return 3
  fi
}

# ---
# Category: Condition
# Since: 0.1.0
# Usage: echo <condition> | l.0_1_0_595550_21144_not.p
# Description: The pipeline version of l.0_1_0_595550_21144_not
# Dependent: not
# ---

l.0_1_0_595550_21144_not.p() {
  local condition
  read -r condition
  l.0_1_0_595550_21144_not "$condition"
}

# ---
# Category: Time
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_now
# Description: Print the timestamp of the number of milliseconds that have elapsed since the Unix epoch (1 January 1970 00:00:00 UTC).
# Description: Require Perl 5.8.8 and higher install if run in Alpine/Busybox systems. And most Unix/Linux operating systems have included Perl 5. See the [Perl Binaries](https://www.cpan.org/ports/binaries.html).
# ---

_l.0_1_0_595550_21144_perl_now() {
  perl -MTime::HiRes=time -e 'printf "%d\n", time * 1000'
}

l.0_1_0_595550_21144_now() {
  local timestamp
  if [[ $_LOBASH_0_1_0_595550_21144_OS == 'MacOS' ]]; then
    # date '+%N' not supported in MacOS.
    _l.0_1_0_595550_21144_perl_now
  else
    # Some Linux systems may not install the Perl module "Time::HiRes".
    # So use date '+%3N' to get milliseconds.
    timestamp=$(date '+%s%3N')

    if [[ ${#timestamp} == 10 ]]; then
      # But the date '+%N' is GNU date feature which not supported in Alpine/Busybox systems.
      _l.0_1_0_595550_21144_perl_now
    else
      printf '%s\n' "$timestamp"
    fi
  fi
}

# ---
# Category: Time
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_now_s
# Description: Print the timestamp of the number of seconds that have elapsed since the Unix epoch (1 January 1970 00:00:00 UTC).
# Dependent: date
# ---

l.0_1_0_595550_21144_now_s() {
  l.0_1_0_595550_21144_date '%s'
}

# ---
# Category: Path
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_pwd
# Description: Return the current working directory as set by the `cd` builtin command.
# ---

l.0_1_0_595550_21144_pwd() {
  printf '%s\n' "$PWD"
}

# ---
# Category: Variable
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_random [<length>=10] [<pattern>=a-zA-Z0-9@#*=[]]
# Description: Return a random string in specific length.
# Description: The `<pattern>` is allowed characters in range.
# ---

l.0_1_0_595550_21144_random() {
  local length=${1:-10}
  local pattern=${2:-a-zA-Z0-9@#*=[]}
  printf '%s\n' "$(LC_ALL=C tr -dc "$pattern" < /dev/urandom | head -c "$length" || true)"
}

# ---
# Category: Path
# Since: 0.1.0
# Dependent: normalize
# Usage: l.0_1_0_595550_21144_relative <path1> <path2>
# ---

l.0_1_0_595550_21144_relative() {
  echo 'todo'
}

# ---
# Category: Util
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_repeat <N> <command_name> [<command_args>]...
# Description: Execute command in N times.
# ---

l.0_1_0_595550_21144_repeat() {
  local -i n=$1
  (( n == 0 )) && return
  (( n < 0 )) && return

  shift
  for n in $(seq "$n"); do
    "$@"
  done
}

# ---
# Category: Color
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_rgb_to_hex <R> <G> <B>
# Dependent: is_number
# Description: Return hex string. Like '#ffffff'
# ---

# Reference: https://github.com/dylanaraps/pure-bash-bible#convert-an-rgb-color-to-hex
l.0_1_0_595550_21144_rgb_to_hex() {
  if (( $# != 3 )); then
    echo 'The arguments size not equal 3' >&2
    return 3
  fi

  if [[ $(l.0_1_0_595550_21144_is_number "$1") == false ]]; then
    echo 'The first argument is not a number' >&2
    return 4
  fi

  if [[ $(l.0_1_0_595550_21144_is_number "$2") == false ]]; then
    echo 'The second argument is not a number' >&2
    return 5
  fi

  if [[ $(l.0_1_0_595550_21144_is_number "$3") == false ]]; then
    echo 'The third argument is not a number' >&2
    return 6
  fi

  printf '#%02x%02x%02x\n' "$1" "$2" "$3"
}

# ---
# Category: System
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_sleep <number_or_float>
# Description: Same to sleep command but support float.
# Description: When run it in Linux/Unix System, the precision of sleep time is 1ms. The deviation of sleep time is 1~2ms by actual measurement.
# Description: When run it in MacOS, the precision of sleep time is 100ms. The deviation of sleep time is 30~40ms by actual measurement.
# ---

# This way is accurate but has bug. Sleep can be cancelled when stdin get 99999 characters in time.
# l.0_1_0_595550_21144_sleep() {
#   read -rst "${1:-1}" -N 99999 || true
# }

# MacOS will show shows "/dev/fd/62: Permission denied" on `exec {_sleep_fd}<> <(true)`. So we make a workaround.
if [[ $OSTYPE =~ darwin ]]; then
  _L_0_1_0_595550_21144_SLEEP_TEMP=$(mktemp -u)
  # Create a FIFO special file
  mkfifo -m 700 "$_L_0_1_0_595550_21144_SLEEP_TEMP"
fi

# Refer to below links
# - https://blog.dhampir.no/content/sleeping-without-a-subprocess-in-bash-and-how-to-sleep-forever
# - https://bash.cyberciti.biz/guide/Opening_the_file_descriptors_for_reading_and_writing
# - https://bash.cyberciti.biz/guide/Closes_the_file_descriptor_(fd)
# - https://bash.cyberciti.biz/guide/Reads_from_the_file_descriptor_(fd)
l.0_1_0_595550_21144_sleep() {
  # Reset IFS in case it’s set to something weird.
  local IFS
  local _sleep_fd

  if [[ $OSTYPE =~ darwin ]]; then
    # MacOS will show shows "/dev/fd/62: Permission denied" on `exec {_sleep_fd}<> <(true)`. So we make a workaround.

    # local _L_0_1_0_595550_21144_SLEEP_TEMP
    # Get available temp file path
    # _L_0_1_0_595550_21144_SLEEP_TEMP=$(mktemp -u)
    # # Create a FIFO special file
    # mkfifo -m 700 "$_L_0_1_0_595550_21144_SLEEP_TEMP"
    exec {_sleep_fd}<>"$_L_0_1_0_595550_21144_SLEEP_TEMP"
    # rm -f "$_L_0_1_0_595550_21144_SLEEP_TEMP"
  else
    exec {_sleep_fd}<> <(true)
  fi

  # Wait for timeout
  read -rst "${1:-1}" -u "$_sleep_fd" || true
  # Close fd
  exec {_sleep_fd}<&-
}

# ---
# Category: Array
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_sort <array_name> [<sort-opts>]...
# Description: Sort an array. The `<sort-opts>` are options of sort command.
# ---

l.0_1_0_595550_21144_sort() {
  local -n l_sort_arg1=$1
  shift
  printf '%s\n' "${l_sort_arg1[@]}" | sort "$@"
}

# ---
# Category: String
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_split <string> <output_array_name> [<delimiter>=' ']
# Description: Splits string by delimiter. The result will be assigned to `<output_array_name>`.
# ---

_l.0_1_0_595550_21144_split() {
  local -i i

  local dLen=${#delimiter}
  local sLen=${#string}

  if [[ $delimiter == '' ]]; then
    for (( i=0; i < sLen; i++ )); do
      printf '%s\n' "${string:$i:1}"
    done
    return 0
  fi

  local -a indexes=()
  local -i a=0 b=0 d

  while (( a < "$sLen" )); do
    for (( b=a+1; b <= sLen; b++ )); do
      d=$(( b - a )) || true
      if (( d > dLen )); then
        break;
      fi

      if [[ "${string:$a:$d}" == "$delimiter" ]]; then
        indexes+=("$a")
      fi
    done
    (( a++ )) || true
  done

  a=0
  for i in "${indexes[@]}"; do
    printf '%s\n' "${string:$a:$(( i - a ))}"
    a=$((i + dLen));
  done

  if (( a + dLen - 1 == sLen )); then
    printf '\n'
  elif (( a < sLen )); then
    printf '%s\n' "${string:$a}"
  fi
}

l.0_1_0_595550_21144_split() {
  local string=$1
  local output=$2
  local delimiter
  if [[ $# == 2 ]]; then
    delimiter=' '
  else
    delimiter="${3}"
  fi

  IFS=$'\n' readarray -t "$output" < <(_l.0_1_0_595550_21144_split)
}

# ---
# Category: String
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_start_with <string> <match>
# Description: Return `true` or `false`. Check if a string starts with given match string.
# ---

l.0_1_0_595550_21144_start_with() {
  [[ $2${1##"$2"} == "$1" ]] && echo true || echo false
}

# ---
# Category: String
# Since: 0.1.0
# Usage: str_include <string> <sub-string>
# Description: Return `true` or `false`. Check if a string includes given match string.
# ---

# shellcheck disable=SC2076

l.0_1_0_595550_21144_str_include() {
  [[ "$1" =~ "$2" ]] && echo true || echo false;
}

# ---
# Category: String
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_str_len <string>
# Description: Return the byte length of string.
# ---

l.0_1_0_595550_21144_str_len() {
  [[ -z ${1:-} ]] && echo 0 && return

  local old_lang old_lc_all bytlen
  [[ -n ${LC_ALL:-} ]] && old_lc_all=$LC_ALL
  [[ -n ${LANG:-} ]] && old_lang=$LANG

  LANG=C LC_ALL=C
  bytlen=${#1}
  printf -- '%s\n' "$bytlen"

  [[ -n ${old_lang:-} ]] && LANG=$old_lang
  if [[ -n ${old_lc_all:-} ]]; then
    LC_ALL=$old_lc_all
  fi
}

# ---
# Category: String
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_str_size <string>
# Description: Return the sum of string letters.
# ---

l.0_1_0_595550_21144_str_size() {
  [[ -z ${1:-} ]] && echo 0 && return

  # It not work with double-width characters when environment LANG is not UTF-8.
  local OLD_LANG
  [[ -n ${LANG:-} ]] && OLD_LANG=$LANG

  LANG=C.UTF-8
  printf '%s\n' "${#1}"

  if [[ -n ${OLD_LANG:-} ]]; then
    LANG=$OLD_LANG
  fi
}

# ---
# Category: Condition
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_strict_has <condition> <what>
# Description: Return `true` or `false`. Check if command/function/alias/keyword/builtin or anything existed.
# Description: `<condition>` Valid value: `command`, `function`, `alias`, `keyword`, `builtin`, `the`
# ---

l.0_1_0_595550_21144_strict_has() {
  local condition="$1"
  local value="$2"

  case "$condition" in
    command)
      [[ -x "$(command -v "$value")" ]] && echo true || echo false;;
    function)
      [[ $(type -t "$value") == function ]] && echo true || echo false;;
    alias)
      [[ $(type -t "$value") == alias ]] && echo true || echo false;;
    keyword)
      [[ $(type -t "$value") == keyword ]] && echo true || echo false;;
    builtin)
      [[ $(type -t "$value") == builtin ]] && echo true || echo false;;
    the)
      type -t "$value" >/dev/null && echo true || echo false;;
    *)
      echo "Invalid Condition: $condition" >&2
      return 3;;
  esac
}

# ---
# Category: Condition
# Since: 0.1.0
# Usage: strict_has_not <condition> <what>
# Dependent: strict_has, not
# Description: Opposite to strict_has.
# ---

l.0_1_0_595550_21144_strict_has_not() {
  local r
  r=$(l.0_1_0_595550_21144_strict_has "$@")
  l.0_1_0_595550_21144_not "$r"
}

# ---
# Category: Arithmetic
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_sub <var_name> [<subtrahend>=1]
# Description: Subtract number with subtrahend.
# ---

l.0_1_0_595550_21144_sub() {
  local -n l_sub_arg1=$1
  ((l_sub_arg1-=${2:-1})) || true
}

# ---
# Category: Debug
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_trace_count [<label>=trace]
# Description: It prints a count which increased after each called.
# Description: Attention: l.0_1_0_595550_21144_trace_count should run in same process. It will not work in subprocess such as $(l.0_1_0_595550_21144_trace_count)
# ---

l.0_1_0_595550_21144_trace_count() {
  local label=${1:-trace}
  local key=_LOBASH_0_1_0_595550_21144_trace_count_$label

  if [[ -z ${!key:-} ]]; then
    declare -g "$key"=0
  fi

  read -r "$key" <<< $(( ${!key} + 1 ))

  printf '[%s] count: %s\n' "$label" "${!key}"
}

# ---
# Category: Debug
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_trace_end
# Description: Close xtrace mode and reset PS4. Cooperated with trace_start.
# ---

l.0_1_0_595550_21144_trace_end() {
  set +o xtrace
  PS4=${_L_0_1_0_595550_21144_TRACE_OLD_PS4:-$PS4}
}

# ---
# Category: Debug
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_trace_stack [label]
# Description: Print current function stack for debug.
# ---

l.0_1_0_595550_21144_trace_stack() {
  printf 'Trace Function Stack:%s\n  # Function (File:Line)\n' "${1:+ $1}"
  for i in $(seq 1 $(( ${#BASH_SOURCE[@]} -1 ))); do
    printf -- '  - %s (%s:%s)\n' "${FUNCNAME[$i]}" "${BASH_SOURCE[$i]}" "${BASH_LINENO[$i]}"
  done
}

# ---
# Category: Debug
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_trace_start [<PS4_level>=2] [<label>]
# Description: PS4_level  Valid Values: `1`, `2`, `3`. Different level changes different prompt message format.
# Description: Open xtrace mode and set PS4. It will print each script line with nice prompt for debug.
# ---
# shellcheck disable=SC2034

l.0_1_0_595550_21144_trace_start() {
  declare -g _L_0_1_0_595550_21144_TRACE_OLD_PS4=$PS4
  local label=${2:-}
  [[ -n "$label" ]] && label="[$label]"

  case ${1:-2} in
    1 )
      PS4='+'${label}'[${LINENO}|${FUNCNAME[0]:+${FUNCNAME[0]}}()|$?${XTRACE_PIPE:+|${PIPESTATUS[*]}}]: '
      ;;
    2 )
      PS4='+'${label}'[$(basename ${BASH_SOURCE[0]}):${LINENO}|${FUNCNAME[0]:+${FUNCNAME[0]}}()|$?${XTRACE_PIPE:+|${PIPESTATUS[*]}}]: '
      ;;
    3 )
      PS4='+'${label}'[${BASH_SOURCE[0]}:${LINENO}|${FUNCNAME[0]:+${FUNCNAME[0]}}()|$?${XTRACE_PIPE:+|${PIPESTATUS[*]}}]: '
      ;;
    * )
      echo "Invalid PS4_LEVEL: $1" >&2
      return 3
      ;;
  esac

  set -o xtrace
}

# ---
# Category: Debug
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_trace_time [label]
# Dependent: now
# Description: Print current timestamp, last timestamp and the elapsed time in millisecond.
# ---

l.0_1_0_595550_21144_trace_time() {
  local label=${1:-debug}
  local key=_LOBASH_0_1_0_595550_21144_TRACE_TIME_$label
  local last_time=${!key:-}
  local current
  current="$(l.0_1_0_595550_21144_now)"

  printf '[%s] Current Timestamp: %s\n' "$label" "$current"

  if [[ -n $last_time ]]; then
    printf '[%s] Last Timestamp: %s\n[%s] Elapsed: %s\n' "$label" "$last_time" "$label" $(( "$(l.0_1_0_595550_21144_now)" - "$last_time" ))
    read -r "$key" <<< "$current"
  else
    declare -g "$key"="$current"
  fi
}

# ---
# Category: String
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_trim <string>
# Description: Remove leading and trailing whitespace from string.
# Dependent: trim_start, trim_end
# ---

l.0_1_0_595550_21144_trim() {
  local str=${1:-}
  str=$(l.0_1_0_595550_21144_trim_start "$str")
  l.0_1_0_595550_21144_trim_end "$str"
}

# ---
# Category: String
# Since: 0.1.0
# Usage: echo <string> | l.0_1_0_595550_21144_trim.p
# Description: The pipeline version of l.0_1_0_595550_21144_trim
# Dependent: trim
# ---

l.0_1_0_595550_21144_trim.p() {
  local str
  read -r str
  l.0_1_0_595550_21144_trim "$str"
}

# ---
# Category: String
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_trim_color <string>
# Description: Remove color escape code in string
# ---

l.0_1_0_595550_21144_trim_color() {
  local ecs=$'\e'
  local str="$1"

  if [[ $_LOBASH_0_1_0_595550_21144_OS == Linux ]]; then
    sed -E "s,${ecs}[[0-9]*(;[0-9]+)*m,,g" <<< "$str"
  elif [[ $_LOBASH_0_1_0_595550_21144_OS == MacOS ]] || [[ $_LOBASH_0_1_0_595550_21144_OS == BSD ]]; then
    sed -E "s,\\${ecs}[[0-9]*(;[0-9]+)*m,,g" <<< "$str"
  else
    echo "Unexpected _LOBASH_0_1_0_595550_21144_OS=$_LOBASH_0_1_0_595550_21144_OS" >&2
    return 5
  fi
}

# ---
# Category: String
# Since: 0.1.0
# Usage: echo <string> | l.0_1_0_595550_21144_trim_color.p
# Description: The pipeline version of l.0_1_0_595550_21144_trim_color
# Dependent: trim_color
# ---

l.0_1_0_595550_21144_trim_color.p() {
  local str
  read -r str
  l.0_1_0_595550_21144_trim_color "$str"
}

# ---
# Category: String
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_trim_end <string> [chars=[[:space:]]]
# Description: Remove trailing whitespace or specified characters from string.
# ---

l.0_1_0_595550_21144_trim_end() {
  local str=${1:-}
  if (( $# < 2 )); then
    # https://stackoverflow.com/a/3352015
    printf '%s\n' "${str%"${str##*[![:space:]]}"}"
  else
    printf '%s\n' "${str%%$2}"
  fi
}

# ---
# Category: String
# Since: 0.1.0
# Usage: echo <string> | l.0_1_0_595550_21144_trim_end.p [chars=[[:space:]]]
# Description: The pipeline version l.0_1_0_595550_21144_trim_end
# Dependent: trim_end
# ---

l.0_1_0_595550_21144_trim_end.p() {
  local str
  IFS='' read -r str

  l.0_1_0_595550_21144_trim_end "$str" "$@"
}

# ---
# Category: String
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_trim_start <string> [<chars>=[[:space:]]]
# Description: Remove leading whitespace or specified characters from string.
# ---

l.0_1_0_595550_21144_trim_start() {
  local str=${1:-}
  if (( $# < 2 )); then
    # https://stackoverflow.com/a/3352015
    printf '%s\n' "${str#"${str%%[![:space:]]*}"}"
  else
    printf '%s\n' "${str##$2}"
  fi
}

# ---
# Category: String
# Since: 0.1.0
# Usage: echo <string> | l.0_1_0_595550_21144_trim_start.p [<chars>=[[:space:]]]
# Description: The pipeline version of l.0_1_0_595550_21144_trim_start
# Dependent: trim_start
# ---

l.0_1_0_595550_21144_trim_start.p() {
  local str
  IFS='' read -r str

  l.0_1_0_595550_21144_trim_start "$str" "$@"
}

# ---
# Category: Array
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_union_array <array_name>...
# Dependent: echo_array
# Description: Create an array of unique values from all given arrays.
# ---

l.0_1_0_595550_21144_union_array() {
  local -n l_union_array_a=$1
  local -n l_union_array_b=$2
  local -a arr
  arr=("${l_union_array_a[@]}" "${l_union_array_b[@]}")
  l.0_1_0_595550_21144_echo_array arr
}

# ---
# Category: String
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_upper_case <string>
# Description: Convert all characters of string to upper case.
# ---

# An alternative for Bash 3.x
# l.0_1_0_595550_21144_upper_case() {
#   tr '[:lower:]' '[:upper:]' <<< ${1:-}
# }

l.0_1_0_595550_21144_upper_case() {
  local str=${1:-}
  printf '%s\n' "${str^^}"
}

# ---
# Category: String
# Since: 0.1.0
# Usage: echo <string> | l.0_1_0_595550_21144_upper_case.p
# Description: The pipeline version of l.0_1_0_595550_21144_upper_case
# Dependent: upper_case
# ---

l.0_1_0_595550_21144_upper_case.p() {
  local str
  IFS='' read -r str
  l.0_1_0_595550_21144_upper_case "$str"
}

# ---
# Category: String
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_upper_first <string>
# Description: Convert the first character of string to upper case.
# ---

# CAVEAT: Requires bash 4+
l.0_1_0_595550_21144_upper_first() {
  local str=${1:-}
  printf '%s\n' "${str^}"
}

# ---
# Category: String
# Since: 0.1.0
# Usage: echo <string> | l.0_1_0_595550_21144_upper_first.p
# Description: The pipeline version of l.0_1_0_595550_21144_upper_first
# Dependent: upper_first
# ---

l.0_1_0_595550_21144_upper_first.p() {
  local str
  IFS='' read -r str
  l.0_1_0_595550_21144_upper_first "$str"
}

# ---
# Category: Variable
# Since: 0.1.0
# Usage: l.0_1_0_595550_21144_xdg_config_home
# Description: Return XDG_CONFIG_HOME. Return `${HOME}/.config` if XDG_CONFIG_HOME not set.
# ---

l.0_1_0_595550_21144_xdg_config_home() {
  printf '%s\n' "${XDG_CONFIG_HOME:-${HOME}/.config}"
}

######################## Public Methods ########################
l.end_with() { l.0_1_0_595550_21144_end_with "$@"; }
l.trim_color() { l.0_1_0_595550_21144_trim_color "$@"; }
l.lower_first() { l.0_1_0_595550_21144_lower_first "$@"; }
l.has() { l.0_1_0_595550_21144_has "$@"; }
l.is_integer() { l.0_1_0_595550_21144_is_integer "$@"; }
l.sort() { l.0_1_0_595550_21144_sort "$@"; }
l.join() { l.0_1_0_595550_21144_join "$@"; }
l.is_number() { l.0_1_0_595550_21144_is_number "$@"; }
l.is_link() { l.0_1_0_595550_21144_is_link "$@"; }
l.echo_array() { l.0_1_0_595550_21144_echo_array "$@"; }
l.now() { l.0_1_0_595550_21144_now "$@"; }
l.is_false() { l.0_1_0_595550_21144_is_false "$@"; }
l.trim_end() { l.0_1_0_595550_21144_trim_end "$@"; }
l.count_lines.p() { l.0_1_0_595550_21144_count_lines.p "$@"; }
l.split() { l.0_1_0_595550_21144_split "$@"; }
l.is_bash() { l.0_1_0_595550_21144_is_bash "$@"; }
l.last() { l.0_1_0_595550_21144_last "$@"; }
l.union_array() { l.0_1_0_595550_21144_union_array "$@"; }
l.dirname() { l.0_1_0_595550_21144_dirname "$@"; }
l.basename() { l.0_1_0_595550_21144_basename "$@"; }
l.not.p() { l.0_1_0_595550_21144_not.p "$@"; }
l.trace_end() { l.0_1_0_595550_21144_trace_end "$@"; }
l.ask() { l.0_1_0_595550_21144_ask "$@"; }
l.count_lines() { l.0_1_0_595550_21144_count_lines "$@"; }
l.str_size() { l.0_1_0_595550_21144_str_size "$@"; }
l.trim_start.p() { l.0_1_0_595550_21144_trim_start.p "$@"; }
l.strict_has() { l.0_1_0_595550_21144_strict_has "$@"; }
l.is_float() { l.0_1_0_595550_21144_is_float "$@"; }
l.hostname() { l.0_1_0_595550_21144_hostname "$@"; }
l.extname() { l.0_1_0_595550_21144_extname "$@"; }
l.is_dir() { l.0_1_0_595550_21144_is_dir "$@"; }
l.is_executable() { l.0_1_0_595550_21144_is_executable "$@"; }
l.cursor_col() { l.0_1_0_595550_21144_cursor_col "$@"; }
l.str_len() { l.0_1_0_595550_21144_str_len "$@"; }
l.repeat() { l.0_1_0_595550_21144_repeat "$@"; }
l.pwd() { l.0_1_0_595550_21144_pwd "$@"; }
l.count_files() { l.0_1_0_595550_21144_count_files "$@"; }
l.trim_color.p() { l.0_1_0_595550_21144_trim_color.p "$@"; }
l.trim() { l.0_1_0_595550_21144_trim "$@"; }
l.str_include() { l.0_1_0_595550_21144_str_include "$@"; }
l.cursor_row() { l.0_1_0_595550_21144_cursor_row "$@"; }
l.is_executable_file() { l.0_1_0_595550_21144_is_executable_file "$@"; }
l.trace_stack() { l.0_1_0_595550_21144_trace_stack "$@"; }
l.compose() { l.0_1_0_595550_21144_compose "$@"; }
l.hex_to_rgb() { l.0_1_0_595550_21144_hex_to_rgb "$@"; }
l.trace_time() { l.0_1_0_595550_21144_trace_time "$@"; }
l.trim.p() { l.0_1_0_595550_21144_trim.p "$@"; }
l.basename.p() { l.0_1_0_595550_21144_basename.p "$@"; }
l.sub() { l.0_1_0_595550_21144_sub "$@"; }
l.inc() { l.0_1_0_595550_21144_inc "$@"; }
l.dirname.p() { l.0_1_0_595550_21144_dirname.p "$@"; }
l.benchmark() { l.0_1_0_595550_21144_benchmark "$@"; }
l.relative() { l.0_1_0_595550_21144_relative "$@"; }
l.is_readable() { l.0_1_0_595550_21144_is_readable "$@"; }
l.is_array() { l.0_1_0_595550_21144_is_array "$@"; }
l.normalize.p() { l.0_1_0_595550_21144_normalize.p "$@"; }
l.choose() { l.0_1_0_595550_21144_choose "$@"; }
l.is_file() { l.0_1_0_595550_21144_is_file "$@"; }
l.trim_start() { l.0_1_0_595550_21144_trim_start "$@"; }
l.now_s() { l.0_1_0_595550_21144_now_s "$@"; }
l.random() { l.0_1_0_595550_21144_random "$@"; }
l.extname.p() { l.0_1_0_595550_21144_extname.p "$@"; }
l.trim_end.p() { l.0_1_0_595550_21144_trim_end.p "$@"; }
l.upper_case() { l.0_1_0_595550_21144_upper_case "$@"; }
l.count_file_lines() { l.0_1_0_595550_21144_count_file_lines "$@"; }
l.sleep() { l.0_1_0_595550_21144_sleep "$@"; }
l.is_writeable() { l.0_1_0_595550_21144_is_writeable "$@"; }
l.match() { l.0_1_0_595550_21144_match "$@"; }
l.cur_function_name() { l.0_1_0_595550_21144_cur_function_name "$@"; }
l.lower_first.p() { l.0_1_0_595550_21144_lower_first.p "$@"; }
l.is_zsh() { l.0_1_0_595550_21144_is_zsh "$@"; }
l.is_true() { l.0_1_0_595550_21144_is_true "$@"; }
l.echo() { l.0_1_0_595550_21144_echo "$@"; }
l.strict_has_not() { l.0_1_0_595550_21144_strict_has_not "$@"; }
l.detect_os() { l.0_1_0_595550_21144_detect_os "$@"; }
l.normalize() { l.0_1_0_595550_21144_normalize "$@"; }
l.not() { l.0_1_0_595550_21144_not "$@"; }
l.lower_case.p() { l.0_1_0_595550_21144_lower_case.p "$@"; }
l.cursor_pos() { l.0_1_0_595550_21144_cursor_pos "$@"; }
l.trace_count() { l.0_1_0_595550_21144_trace_count "$@"; }
l.first() { l.0_1_0_595550_21144_first "$@"; }
l.rgb_to_hex() { l.0_1_0_595550_21144_rgb_to_hex "$@"; }
l.array_include() { l.0_1_0_595550_21144_array_include "$@"; }
l.xdg_config_home() { l.0_1_0_595550_21144_xdg_config_home "$@"; }
l.trace_start() { l.0_1_0_595550_21144_trace_start "$@"; }
l.upper_case.p() { l.0_1_0_595550_21144_upper_case.p "$@"; }
l.lower_case() { l.0_1_0_595550_21144_lower_case "$@"; }
l.if() { l.0_1_0_595550_21144_if "$@"; }
l.start_with() { l.0_1_0_595550_21144_start_with "$@"; }
l.upper_first.p() { l.0_1_0_595550_21144_upper_first.p "$@"; }
l.date() { l.0_1_0_595550_21144_date "$@"; }
l.upper_first() { l.0_1_0_595550_21144_upper_first "$@"; }
